\chapter{Implementierung}
\label{chap:implementierung}

\section{Technologische Basis}
Die Implementierung basiert auf einer sorgfältig ausgewählten technologischen Basis, die modernste Tools und Frameworks kombiniert, um eine effiziente, skalierbare und sichere Lösung zu gewährleisten. Die Haupttechnologien umfassen:

\begin{itemize}
    \item \textbf{Frontend:} Die Entwicklung des Frontends erfolgt mit React und TypeScript, um eine robuste und komponentenbasierte Architektur zu gewährleisten. Primereact wird als UI-Bibliothek eingesetzt, um eine konsistente Benutzeroberfläche zu realisieren und die Entwicklungszeit durch vorgefertigte, anpassbare Komponenten zu verkürzen. Vite dient als modernes Build-Tool, das durch schnelle Hot-Module-Replacement-Funktionen eine produktive Entwicklungsumgebung bietet.
    
    \item \textbf{Backend:} Das Backend basiert auf .NET Core und stellt RESTful APIs bereit, die eine zuverlässige und standardisierte Kommunikation ermöglichen. Middleware-Services wurden implementiert, um Aufgaben wie Authentifizierung, Fehlerbehandlung und Protokollierung zu übernehmen. Die Verwendung von Azure Active Directory (AAD) gewährleistet eine sichere Authentifizierung und rollenbasierte Zugriffskontrolle.
    
    \item \textbf{Azure Cloud:} Die Azure Cloud spielt eine zentrale Rolle bei der Implementierung, da sie Dienste wie Azure Service Bus zur asynchronen Kommunikation zwischen Systemkomponenten bereitstellt. Außerdem ermöglicht sie eine flexible und skalierbare Infrastruktur, die für die Anforderungen des Systems optimiert ist.
    
    \item \textbf{DevOps:} Zur Optimierung des Entwicklungs- und Bereitstellungsprozesses werden automatisierte CI/CD-Pipelines mit Azure Pipelines verwendet. Diese Pipelines integrieren automatisierte Tests, Builds und Deployments, um eine hohe Qualität und schnelle Iterationen sicherzustellen.
    
    \item \textbf{Versionskontrolle mit Git:} Git wurde als zentrales Versionskontrollsystem genutzt. Es ermöglicht effizientes Arbeiten mit Feature-Branches, Pull-Requests und das einfache Nachverfolgen von Änderungen. GitHub wurde als zentrale Plattform für die Zusammenarbeit und Code-Reviews verwendet.
    
    \item \textbf{SCRUM-Board:} Ein digitales SCRUM-Board (z. B. Azure Boards) wurde eingesetzt, um Aufgaben zu planen, zu priorisieren und den Fortschritt in Sprints zu überwachen.

    \item \textbf{Testautomatisierung:} Tools wie Jest und React Testing Library wurden zur Sicherstellung der Codequalität eingesetzt. Automatisierte Tests wurden in die CI/CD-Pipeline integriert, um frühzeitig Fehler zu erkennen und zu beheben.

    \item \textbf{Containerisierung:} Docker wurde für die Bereitstellung einer konsistenten Entwicklungs- und Produktionsumgebung genutzt. Docker-Images für das Frontend und Backend werden in einer Azure Container Registry (ACR) gespeichert und ermöglichen schnelle und skalierbare Deployments.
    
    \item \textbf{Monitoring und Fehleranalyse:} Azure Application Insights wurde zur Überwachung von Systemmetriken wie Antwortzeiten, Fehlerraten und Benutzerinteraktionen integriert. Dies ermöglicht eine effiziente Fehlerdiagnose und Performance-Optimierung.
\end{itemize}

Diese technologische Basis bildet die Grundlage für die Implementierung einer modernen, leistungsfähigen Softwarelösung, die den Anforderungen an Skalierbarkeit, Sicherheit und Benutzerfreundlichkeit gerecht wird.

\section{Detailierte Architektur}
\subsection{Frontend-Architektur}
Das Frontend wurde mit einer komponentenbasierten Architektur entwickelt, die eine modulare und wiederverwendbare Struktur ermöglicht:
\begin{itemize}
    \item \textbf{Komponenten:} Jedes UI-Element wurde als eigenständige Komponente entwickelt, um Wartbarkeit und Wiederverwendbarkeit zu maximieren.
    \item \textbf{State-Management:} Für die Verwaltung globaler Zustände kommen Redux Toolkit und Zustand zum Einsatz.
    \item \textbf{Datenvisualisierung:} ApexCharts und React-ApexCharts werden zur Darstellung von Donut- und Radarcharts verwendet.
\end{itemize}

\subsubsection*{Anwendungsbeispiele und Screenshots}
Die folgende Abbildung zeigt die Hauptansichten der Anwendung:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/dashboard.png}
    \caption{Dashboard der Anwendung mit Übersicht über Mitarbeitendengespräche}
    \label{fig:dashboard}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/radar_chart.png}
    \caption{Radarchart-Visualisierung der Mitarbeitendengesprächsdaten}
    \label{fig:radar_chart}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/data_entry_form.png}
    \caption{Formular zur Eingabe von Mitarbeitendendaten}
    \label{fig:data_entry}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/settings.png}
    \caption{Einstellungsseite zur Verwaltung von Berechtigungen und Rollen}
    \label{fig:settings}
\end{figure}

\subsubsection*{Erläuterung der Komponenten und Codebeispiele}
Die Umsetzung des Frontends wurde durch eine strukturierte Entwicklung modularer Komponenten realisiert. Die folgende Komponente zeigt die Implementierung eines Donut-Charts, das für die Visualisierung von Daten genutzt wird:

\begin{listing}[H]
\begin{minted}[linenos, frame=single, fontsize=\small]{javascript}
import React from 'react';
import { Chart } from 'react-apexcharts';

const DonutChart = ({ data, labels }) => {
  const options = {
    chart: {
      type: 'donut',
    },
    labels,
  };

  return (
    <Chart
      options={options}
      series={data}
      type="donut"
      width="500"
    />
  );
};

export default DonutChart;
\end{minted}
\caption{Implementierung eines Donut-Charts mit ApexCharts}
\label{lst:donut_chart}
\end{listing}

Ein weiteres Beispiel ist die Komponente für die Dateneingabe, die mit Formularvalidierung ausgestattet ist:

\begin{listing}[H]
\begin{minted}[linenos, frame=single, fontsize=\small]{javascript}
import React, { useState } from 'react';

const DataEntryForm = () => {
  const [formData, setFormData] = useState({ name: '', role: '', feedback: '' });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({ ...formData, [name]: value });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Submitted data:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleChange}
        />
      </label>
      <label>
        Role:
        <input
          type="text"
          name="role"
          value={formData.role}
          onChange={handleChange}
        />
      </label>
      <label>
        Feedback:
        <textarea
          name="feedback"
          value={formData.feedback}
          onChange={handleChange}
        />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
};

export default DataEntryForm;
\end{minted}
\caption{Komponente zur Dateneingabe mit Validierung}
\label{lst:data_entry_form}
\end{listing}

Diese Beispiele zeigen die modulare Entwicklung des Frontends, die Wartbarkeit und Erweiterbarkeit des Codes gewährleistet.

\subsection{Backend-Architektur}
Das Backend basiert auf einer mehrschichtigen Architektur, die eine klare Trennung von Verantwortlichkeiten gewährleistet. Diese Architektur stellt die Grundlage für eine effiziente und skalierbare Verarbeitung von Mitarbeitendengesprächsdaten dar.

\subsection{Technologische Basis}
Die Entwicklung des Backends erfordert eine fundierte Auswahl moderner Technologien und Methoden, um zentrale Anforderungen wie Sicherheit, Performanz, Skalierbarkeit und Datenverarbeitung zu erfüllen. Folgende Komponenten sind integraler Bestandteil der Implementierung:
\begin{itemize}
    \item \textbf{API-Entwicklung:} Implementierung von RESTful APIs mit .NET Core, die eine zuverlässige und standardisierte Datenübertragung ermöglichen.
    \item \textbf{Cloud-Technologien:} Integration von Microsoft Azure-Diensten wie Azure SQL und Azure Service Bus zur Unterstützung asynchroner Kommunikation und Datenverarbeitung.
    \item \textbf{Sicherheitsmechanismen:} Einsatz von Azure Active Directory (AAD) für Multi-Faktor-Authentifizierung und rollenbasierte Zugriffskontrolle.
    \item \textbf{Datenverarbeitung:} Nutzung skalierbarer Algorithmen zur Aggregation und Transformation komplexer Datenstrukturen.
\end{itemize}

\subsection{Komponenten der Backend-Architektur}
Die Backend-Architektur folgt einer schichtbasierten Struktur, die eine klare Trennung von Verantwortlichkeiten ermöglicht. Diese modulare Architektur erleichtert die Wartbarkeit, Skalierbarkeit und Testbarkeit des Systems. Die Hauptkomponenten sind:

\begin{itemize}
    \item \textbf{Controller-Schicht:} Diese Schicht verarbeitet HTTP-Anfragen und leitet sie an entsprechende Services weiter. Alternativen wie GraphQL wurden geprüft, aber aufgrund der Einfachheit und Standardisierung fiel die Wahl auf RESTful APIs \cite{fielding2000rest}.
    \item \textbf{Service-Schicht:} Diese Schicht implementiert die Geschäftslogik und orchestriert zwischen Controllern und Repositories. Alternativansätze, wie eine direkte Einbindung der Logik in die Controller, wurden verworfen, da sie die Wartbarkeit reduzieren würden.
    \item \textbf{Repository-Schicht:} Diese Schicht abstrahiert die Datenbankzugriffe mithilfe von Entity Framework Core und sorgt für konsistente Operationen \cite{efCoreDocs2023}.
    \item \textbf{Middleware:} Hier werden zentrale Funktionen wie Authentifizierung und Fehlerbehandlung implementiert, was die Controllerschicht entlastet.
\end{itemize}

\subsection{API-Endpunkte}
Zur Interaktion mit den Daten des Systems wurden verschiedene API-Endpunkte implementiert. Tabelle \ref{table:http-methods} listet die wesentlichen HTTP-Methoden und URLs zur Manipulation von Ressourcen:

\begin{table}[H]
\caption{HTTP-Methoden und URLs zur Manipulation von Ressourcen}
\label{table:http-methods}
\raggedright
{\scriptsize Quelle: Eigene Darstellung} \\[0.3em]
\renewcommand{\arraystretch}{1.1}
\setlength{\tabcolsep}{1.8pt}
\begin{tabularx}{\textwidth}{>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{5.5cm}|>{\raggedright\arraybackslash}m{6.5cm}}
\hline
\textbf{HTTP-Methoden} & \textbf{URL /odata/v\{version\}} & \textbf{Beschreibung} \\\hline
GET & /employeeAppraisals/\{appraisalId\} & Lese ein einzelnes Mitarbeitergespräch anhand der eindeutigen ID. \\\hline
GET & /employeeAppraisals & Lese alle Mitarbeitergespräche zur Analyse und Berichterstellung. \\\hline
POST & /employeeAppraisals & Erstelle ein neues Mitarbeitergespräch und speichere es im System. \\\hline
GET & /employeeAppraisals/all & Lese alle verfügbaren Mitarbeitergespräche, einschließlich archivierter Daten. \\\hline
GET & /employeeAppraisals/last & Lese die zuletzt eingetragenen Mitarbeitergespräche. \\\hline
POST & /employeeAppraisals/CheckBox & Erstelle oder aktualisiere Checkbox-Daten für Mitarbeitergespräche. \\\hline
\end{tabularx}
\end{table}

\subsection{Fehleranalyse und Herausforderungen während der Implementierung}
Während der Implementierung traten verschiedene Herausforderungen auf. Ein prominentes Beispiel war die Datenvisualisierung im Radarchart, die durch die Anpassung der Datenstruktur gelöst wurde. Diese Änderungen wurden durch detaillierte Tests validiert.
